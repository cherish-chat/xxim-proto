// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: conversation.peer.proto

package peerpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GroupServiceClient is the client API for GroupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GroupServiceClient interface {
	GroupAfterKeepAlive(ctx context.Context, in *GroupAfterKeepAliveReq, opts ...grpc.CallOption) (*GroupAfterKeepAliveResp, error)
	GroupAfterOnline(ctx context.Context, in *GroupAfterOnlineReq, opts ...grpc.CallOption) (*GroupAfterOnlineResp, error)
	GroupAfterOffline(ctx context.Context, in *GroupAfterOfflineReq, opts ...grpc.CallOption) (*GroupAfterOfflineResp, error)
	GroupCreate(ctx context.Context, in *GroupCreateReq, opts ...grpc.CallOption) (*GroupCreateResp, error)
	CountJoinGroup(ctx context.Context, in *CountJoinGroupReq, opts ...grpc.CallOption) (*CountJoinGroupResp, error)
	CountCreateGroup(ctx context.Context, in *CountCreateGroupReq, opts ...grpc.CallOption) (*CountCreateGroupResp, error)
	ListGroupSubscribers(ctx context.Context, in *ListGroupSubscribersReq, opts ...grpc.CallOption) (*ListGroupSubscribersResp, error)
	ListMyJoinedGroup(ctx context.Context, in *ListMyJoinedGroupReq, opts ...grpc.CallOption) (*ListMyJoinedGroupResp, error)
}

type groupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGroupServiceClient(cc grpc.ClientConnInterface) GroupServiceClient {
	return &groupServiceClient{cc}
}

func (c *groupServiceClient) GroupAfterKeepAlive(ctx context.Context, in *GroupAfterKeepAliveReq, opts ...grpc.CallOption) (*GroupAfterKeepAliveResp, error) {
	out := new(GroupAfterKeepAliveResp)
	err := c.cc.Invoke(ctx, "/pb.groupService/GroupAfterKeepAlive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) GroupAfterOnline(ctx context.Context, in *GroupAfterOnlineReq, opts ...grpc.CallOption) (*GroupAfterOnlineResp, error) {
	out := new(GroupAfterOnlineResp)
	err := c.cc.Invoke(ctx, "/pb.groupService/GroupAfterOnline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) GroupAfterOffline(ctx context.Context, in *GroupAfterOfflineReq, opts ...grpc.CallOption) (*GroupAfterOfflineResp, error) {
	out := new(GroupAfterOfflineResp)
	err := c.cc.Invoke(ctx, "/pb.groupService/GroupAfterOffline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) GroupCreate(ctx context.Context, in *GroupCreateReq, opts ...grpc.CallOption) (*GroupCreateResp, error) {
	out := new(GroupCreateResp)
	err := c.cc.Invoke(ctx, "/pb.groupService/GroupCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) CountJoinGroup(ctx context.Context, in *CountJoinGroupReq, opts ...grpc.CallOption) (*CountJoinGroupResp, error) {
	out := new(CountJoinGroupResp)
	err := c.cc.Invoke(ctx, "/pb.groupService/CountJoinGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) CountCreateGroup(ctx context.Context, in *CountCreateGroupReq, opts ...grpc.CallOption) (*CountCreateGroupResp, error) {
	out := new(CountCreateGroupResp)
	err := c.cc.Invoke(ctx, "/pb.groupService/CountCreateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) ListGroupSubscribers(ctx context.Context, in *ListGroupSubscribersReq, opts ...grpc.CallOption) (*ListGroupSubscribersResp, error) {
	out := new(ListGroupSubscribersResp)
	err := c.cc.Invoke(ctx, "/pb.groupService/ListGroupSubscribers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) ListMyJoinedGroup(ctx context.Context, in *ListMyJoinedGroupReq, opts ...grpc.CallOption) (*ListMyJoinedGroupResp, error) {
	out := new(ListMyJoinedGroupResp)
	err := c.cc.Invoke(ctx, "/pb.groupService/ListMyJoinedGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroupServiceServer is the server API for GroupService service.
// All implementations must embed UnimplementedGroupServiceServer
// for forward compatibility
type GroupServiceServer interface {
	GroupAfterKeepAlive(context.Context, *GroupAfterKeepAliveReq) (*GroupAfterKeepAliveResp, error)
	GroupAfterOnline(context.Context, *GroupAfterOnlineReq) (*GroupAfterOnlineResp, error)
	GroupAfterOffline(context.Context, *GroupAfterOfflineReq) (*GroupAfterOfflineResp, error)
	GroupCreate(context.Context, *GroupCreateReq) (*GroupCreateResp, error)
	CountJoinGroup(context.Context, *CountJoinGroupReq) (*CountJoinGroupResp, error)
	CountCreateGroup(context.Context, *CountCreateGroupReq) (*CountCreateGroupResp, error)
	ListGroupSubscribers(context.Context, *ListGroupSubscribersReq) (*ListGroupSubscribersResp, error)
	ListMyJoinedGroup(context.Context, *ListMyJoinedGroupReq) (*ListMyJoinedGroupResp, error)
	mustEmbedUnimplementedGroupServiceServer()
}

// UnimplementedGroupServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGroupServiceServer struct {
}

func (UnimplementedGroupServiceServer) GroupAfterKeepAlive(context.Context, *GroupAfterKeepAliveReq) (*GroupAfterKeepAliveResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GroupAfterKeepAlive not implemented")
}
func (UnimplementedGroupServiceServer) GroupAfterOnline(context.Context, *GroupAfterOnlineReq) (*GroupAfterOnlineResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GroupAfterOnline not implemented")
}
func (UnimplementedGroupServiceServer) GroupAfterOffline(context.Context, *GroupAfterOfflineReq) (*GroupAfterOfflineResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GroupAfterOffline not implemented")
}
func (UnimplementedGroupServiceServer) GroupCreate(context.Context, *GroupCreateReq) (*GroupCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GroupCreate not implemented")
}
func (UnimplementedGroupServiceServer) CountJoinGroup(context.Context, *CountJoinGroupReq) (*CountJoinGroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountJoinGroup not implemented")
}
func (UnimplementedGroupServiceServer) CountCreateGroup(context.Context, *CountCreateGroupReq) (*CountCreateGroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountCreateGroup not implemented")
}
func (UnimplementedGroupServiceServer) ListGroupSubscribers(context.Context, *ListGroupSubscribersReq) (*ListGroupSubscribersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroupSubscribers not implemented")
}
func (UnimplementedGroupServiceServer) ListMyJoinedGroup(context.Context, *ListMyJoinedGroupReq) (*ListMyJoinedGroupResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMyJoinedGroup not implemented")
}
func (UnimplementedGroupServiceServer) mustEmbedUnimplementedGroupServiceServer() {}

// UnsafeGroupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroupServiceServer will
// result in compilation errors.
type UnsafeGroupServiceServer interface {
	mustEmbedUnimplementedGroupServiceServer()
}

func RegisterGroupServiceServer(s grpc.ServiceRegistrar, srv GroupServiceServer) {
	s.RegisterService(&GroupService_ServiceDesc, srv)
}

func _GroupService_GroupAfterKeepAlive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupAfterKeepAliveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).GroupAfterKeepAlive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.groupService/GroupAfterKeepAlive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).GroupAfterKeepAlive(ctx, req.(*GroupAfterKeepAliveReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_GroupAfterOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupAfterOnlineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).GroupAfterOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.groupService/GroupAfterOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).GroupAfterOnline(ctx, req.(*GroupAfterOnlineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_GroupAfterOffline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupAfterOfflineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).GroupAfterOffline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.groupService/GroupAfterOffline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).GroupAfterOffline(ctx, req.(*GroupAfterOfflineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_GroupCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).GroupCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.groupService/GroupCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).GroupCreate(ctx, req.(*GroupCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_CountJoinGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountJoinGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).CountJoinGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.groupService/CountJoinGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).CountJoinGroup(ctx, req.(*CountJoinGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_CountCreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountCreateGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).CountCreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.groupService/CountCreateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).CountCreateGroup(ctx, req.(*CountCreateGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_ListGroupSubscribers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupSubscribersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).ListGroupSubscribers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.groupService/ListGroupSubscribers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).ListGroupSubscribers(ctx, req.(*ListGroupSubscribersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_ListMyJoinedGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMyJoinedGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).ListMyJoinedGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.groupService/ListMyJoinedGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).ListMyJoinedGroup(ctx, req.(*ListMyJoinedGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

// GroupService_ServiceDesc is the grpc.ServiceDesc for GroupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GroupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.groupService",
	HandlerType: (*GroupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GroupAfterKeepAlive",
			Handler:    _GroupService_GroupAfterKeepAlive_Handler,
		},
		{
			MethodName: "GroupAfterOnline",
			Handler:    _GroupService_GroupAfterOnline_Handler,
		},
		{
			MethodName: "GroupAfterOffline",
			Handler:    _GroupService_GroupAfterOffline_Handler,
		},
		{
			MethodName: "GroupCreate",
			Handler:    _GroupService_GroupCreate_Handler,
		},
		{
			MethodName: "CountJoinGroup",
			Handler:    _GroupService_CountJoinGroup_Handler,
		},
		{
			MethodName: "CountCreateGroup",
			Handler:    _GroupService_CountCreateGroup_Handler,
		},
		{
			MethodName: "ListGroupSubscribers",
			Handler:    _GroupService_ListGroupSubscribers_Handler,
		},
		{
			MethodName: "ListMyJoinedGroup",
			Handler:    _GroupService_ListMyJoinedGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "conversation.peer.proto",
}

// FriendServiceClient is the client API for FriendService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FriendServiceClient interface {
	FriendAfterKeepAlive(ctx context.Context, in *FriendAfterKeepAliveReq, opts ...grpc.CallOption) (*FriendAfterKeepAliveResp, error)
	FriendAfterOnline(ctx context.Context, in *FriendAfterOnlineReq, opts ...grpc.CallOption) (*FriendAfterOnlineResp, error)
	FriendAfterOffline(ctx context.Context, in *FriendAfterOfflineReq, opts ...grpc.CallOption) (*FriendAfterOfflineResp, error)
	FriendApply(ctx context.Context, in *FriendApplyReq, opts ...grpc.CallOption) (*FriendApplyResp, error)
	FriendApplyHandle(ctx context.Context, in *FriendApplyHandleReq, opts ...grpc.CallOption) (*FriendApplyHandleResp, error)
	ListFriendApply(ctx context.Context, in *ListFriendApplyReq, opts ...grpc.CallOption) (*ListFriendApplyResp, error)
	CountFriend(ctx context.Context, in *CountFriendReq, opts ...grpc.CallOption) (*CountFriendResp, error)
}

type friendServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFriendServiceClient(cc grpc.ClientConnInterface) FriendServiceClient {
	return &friendServiceClient{cc}
}

func (c *friendServiceClient) FriendAfterKeepAlive(ctx context.Context, in *FriendAfterKeepAliveReq, opts ...grpc.CallOption) (*FriendAfterKeepAliveResp, error) {
	out := new(FriendAfterKeepAliveResp)
	err := c.cc.Invoke(ctx, "/pb.friendService/FriendAfterKeepAlive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *friendServiceClient) FriendAfterOnline(ctx context.Context, in *FriendAfterOnlineReq, opts ...grpc.CallOption) (*FriendAfterOnlineResp, error) {
	out := new(FriendAfterOnlineResp)
	err := c.cc.Invoke(ctx, "/pb.friendService/FriendAfterOnline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *friendServiceClient) FriendAfterOffline(ctx context.Context, in *FriendAfterOfflineReq, opts ...grpc.CallOption) (*FriendAfterOfflineResp, error) {
	out := new(FriendAfterOfflineResp)
	err := c.cc.Invoke(ctx, "/pb.friendService/FriendAfterOffline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *friendServiceClient) FriendApply(ctx context.Context, in *FriendApplyReq, opts ...grpc.CallOption) (*FriendApplyResp, error) {
	out := new(FriendApplyResp)
	err := c.cc.Invoke(ctx, "/pb.friendService/FriendApply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *friendServiceClient) FriendApplyHandle(ctx context.Context, in *FriendApplyHandleReq, opts ...grpc.CallOption) (*FriendApplyHandleResp, error) {
	out := new(FriendApplyHandleResp)
	err := c.cc.Invoke(ctx, "/pb.friendService/FriendApplyHandle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *friendServiceClient) ListFriendApply(ctx context.Context, in *ListFriendApplyReq, opts ...grpc.CallOption) (*ListFriendApplyResp, error) {
	out := new(ListFriendApplyResp)
	err := c.cc.Invoke(ctx, "/pb.friendService/ListFriendApply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *friendServiceClient) CountFriend(ctx context.Context, in *CountFriendReq, opts ...grpc.CallOption) (*CountFriendResp, error) {
	out := new(CountFriendResp)
	err := c.cc.Invoke(ctx, "/pb.friendService/CountFriend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FriendServiceServer is the server API for FriendService service.
// All implementations must embed UnimplementedFriendServiceServer
// for forward compatibility
type FriendServiceServer interface {
	FriendAfterKeepAlive(context.Context, *FriendAfterKeepAliveReq) (*FriendAfterKeepAliveResp, error)
	FriendAfterOnline(context.Context, *FriendAfterOnlineReq) (*FriendAfterOnlineResp, error)
	FriendAfterOffline(context.Context, *FriendAfterOfflineReq) (*FriendAfterOfflineResp, error)
	FriendApply(context.Context, *FriendApplyReq) (*FriendApplyResp, error)
	FriendApplyHandle(context.Context, *FriendApplyHandleReq) (*FriendApplyHandleResp, error)
	ListFriendApply(context.Context, *ListFriendApplyReq) (*ListFriendApplyResp, error)
	CountFriend(context.Context, *CountFriendReq) (*CountFriendResp, error)
	mustEmbedUnimplementedFriendServiceServer()
}

// UnimplementedFriendServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFriendServiceServer struct {
}

func (UnimplementedFriendServiceServer) FriendAfterKeepAlive(context.Context, *FriendAfterKeepAliveReq) (*FriendAfterKeepAliveResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FriendAfterKeepAlive not implemented")
}
func (UnimplementedFriendServiceServer) FriendAfterOnline(context.Context, *FriendAfterOnlineReq) (*FriendAfterOnlineResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FriendAfterOnline not implemented")
}
func (UnimplementedFriendServiceServer) FriendAfterOffline(context.Context, *FriendAfterOfflineReq) (*FriendAfterOfflineResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FriendAfterOffline not implemented")
}
func (UnimplementedFriendServiceServer) FriendApply(context.Context, *FriendApplyReq) (*FriendApplyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FriendApply not implemented")
}
func (UnimplementedFriendServiceServer) FriendApplyHandle(context.Context, *FriendApplyHandleReq) (*FriendApplyHandleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FriendApplyHandle not implemented")
}
func (UnimplementedFriendServiceServer) ListFriendApply(context.Context, *ListFriendApplyReq) (*ListFriendApplyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFriendApply not implemented")
}
func (UnimplementedFriendServiceServer) CountFriend(context.Context, *CountFriendReq) (*CountFriendResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountFriend not implemented")
}
func (UnimplementedFriendServiceServer) mustEmbedUnimplementedFriendServiceServer() {}

// UnsafeFriendServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FriendServiceServer will
// result in compilation errors.
type UnsafeFriendServiceServer interface {
	mustEmbedUnimplementedFriendServiceServer()
}

func RegisterFriendServiceServer(s grpc.ServiceRegistrar, srv FriendServiceServer) {
	s.RegisterService(&FriendService_ServiceDesc, srv)
}

func _FriendService_FriendAfterKeepAlive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FriendAfterKeepAliveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FriendServiceServer).FriendAfterKeepAlive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.friendService/FriendAfterKeepAlive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FriendServiceServer).FriendAfterKeepAlive(ctx, req.(*FriendAfterKeepAliveReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FriendService_FriendAfterOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FriendAfterOnlineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FriendServiceServer).FriendAfterOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.friendService/FriendAfterOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FriendServiceServer).FriendAfterOnline(ctx, req.(*FriendAfterOnlineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FriendService_FriendAfterOffline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FriendAfterOfflineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FriendServiceServer).FriendAfterOffline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.friendService/FriendAfterOffline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FriendServiceServer).FriendAfterOffline(ctx, req.(*FriendAfterOfflineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FriendService_FriendApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FriendApplyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FriendServiceServer).FriendApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.friendService/FriendApply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FriendServiceServer).FriendApply(ctx, req.(*FriendApplyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FriendService_FriendApplyHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FriendApplyHandleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FriendServiceServer).FriendApplyHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.friendService/FriendApplyHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FriendServiceServer).FriendApplyHandle(ctx, req.(*FriendApplyHandleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FriendService_ListFriendApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFriendApplyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FriendServiceServer).ListFriendApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.friendService/ListFriendApply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FriendServiceServer).ListFriendApply(ctx, req.(*ListFriendApplyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FriendService_CountFriend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountFriendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FriendServiceServer).CountFriend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.friendService/CountFriend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FriendServiceServer).CountFriend(ctx, req.(*CountFriendReq))
	}
	return interceptor(ctx, in, info, handler)
}

// FriendService_ServiceDesc is the grpc.ServiceDesc for FriendService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FriendService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.friendService",
	HandlerType: (*FriendServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FriendAfterKeepAlive",
			Handler:    _FriendService_FriendAfterKeepAlive_Handler,
		},
		{
			MethodName: "FriendAfterOnline",
			Handler:    _FriendService_FriendAfterOnline_Handler,
		},
		{
			MethodName: "FriendAfterOffline",
			Handler:    _FriendService_FriendAfterOffline_Handler,
		},
		{
			MethodName: "FriendApply",
			Handler:    _FriendService_FriendApply_Handler,
		},
		{
			MethodName: "FriendApplyHandle",
			Handler:    _FriendService_FriendApplyHandle_Handler,
		},
		{
			MethodName: "ListFriendApply",
			Handler:    _FriendService_ListFriendApply_Handler,
		},
		{
			MethodName: "CountFriend",
			Handler:    _FriendService_CountFriend_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "conversation.peer.proto",
}

// ChannelServiceClient is the client API for ChannelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChannelServiceClient interface {
	ChannelAfterKeepAlive(ctx context.Context, in *ChannelAfterKeepAliveReq, opts ...grpc.CallOption) (*ChannelAfterKeepAliveResp, error)
	ChannelAfterOnline(ctx context.Context, in *ChannelAfterOnlineReq, opts ...grpc.CallOption) (*ChannelAfterOnlineResp, error)
	ChannelAfterOffline(ctx context.Context, in *ChannelAfterOfflineReq, opts ...grpc.CallOption) (*ChannelAfterOfflineResp, error)
	UpsertChannelMember(ctx context.Context, in *UpsertChannelMemberReq, opts ...grpc.CallOption) (*UpsertChannelMemberResp, error)
	DeleteChannelMember(ctx context.Context, in *DeleteChannelMemberReq, opts ...grpc.CallOption) (*DeleteChannelMemberResp, error)
	ListChannelSubscribers(ctx context.Context, in *ListChannelSubscribersReq, opts ...grpc.CallOption) (*ListChannelSubscribersResp, error)
	ListMyChannels(ctx context.Context, in *ListMyChannelsReq, opts ...grpc.CallOption) (*ListMyChannelsResp, error)
}

type channelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChannelServiceClient(cc grpc.ClientConnInterface) ChannelServiceClient {
	return &channelServiceClient{cc}
}

func (c *channelServiceClient) ChannelAfterKeepAlive(ctx context.Context, in *ChannelAfterKeepAliveReq, opts ...grpc.CallOption) (*ChannelAfterKeepAliveResp, error) {
	out := new(ChannelAfterKeepAliveResp)
	err := c.cc.Invoke(ctx, "/pb.channelService/ChannelAfterKeepAlive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) ChannelAfterOnline(ctx context.Context, in *ChannelAfterOnlineReq, opts ...grpc.CallOption) (*ChannelAfterOnlineResp, error) {
	out := new(ChannelAfterOnlineResp)
	err := c.cc.Invoke(ctx, "/pb.channelService/ChannelAfterOnline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) ChannelAfterOffline(ctx context.Context, in *ChannelAfterOfflineReq, opts ...grpc.CallOption) (*ChannelAfterOfflineResp, error) {
	out := new(ChannelAfterOfflineResp)
	err := c.cc.Invoke(ctx, "/pb.channelService/ChannelAfterOffline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) UpsertChannelMember(ctx context.Context, in *UpsertChannelMemberReq, opts ...grpc.CallOption) (*UpsertChannelMemberResp, error) {
	out := new(UpsertChannelMemberResp)
	err := c.cc.Invoke(ctx, "/pb.channelService/UpsertChannelMember", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) DeleteChannelMember(ctx context.Context, in *DeleteChannelMemberReq, opts ...grpc.CallOption) (*DeleteChannelMemberResp, error) {
	out := new(DeleteChannelMemberResp)
	err := c.cc.Invoke(ctx, "/pb.channelService/DeleteChannelMember", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) ListChannelSubscribers(ctx context.Context, in *ListChannelSubscribersReq, opts ...grpc.CallOption) (*ListChannelSubscribersResp, error) {
	out := new(ListChannelSubscribersResp)
	err := c.cc.Invoke(ctx, "/pb.channelService/ListChannelSubscribers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channelServiceClient) ListMyChannels(ctx context.Context, in *ListMyChannelsReq, opts ...grpc.CallOption) (*ListMyChannelsResp, error) {
	out := new(ListMyChannelsResp)
	err := c.cc.Invoke(ctx, "/pb.channelService/ListMyChannels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChannelServiceServer is the server API for ChannelService service.
// All implementations must embed UnimplementedChannelServiceServer
// for forward compatibility
type ChannelServiceServer interface {
	ChannelAfterKeepAlive(context.Context, *ChannelAfterKeepAliveReq) (*ChannelAfterKeepAliveResp, error)
	ChannelAfterOnline(context.Context, *ChannelAfterOnlineReq) (*ChannelAfterOnlineResp, error)
	ChannelAfterOffline(context.Context, *ChannelAfterOfflineReq) (*ChannelAfterOfflineResp, error)
	UpsertChannelMember(context.Context, *UpsertChannelMemberReq) (*UpsertChannelMemberResp, error)
	DeleteChannelMember(context.Context, *DeleteChannelMemberReq) (*DeleteChannelMemberResp, error)
	ListChannelSubscribers(context.Context, *ListChannelSubscribersReq) (*ListChannelSubscribersResp, error)
	ListMyChannels(context.Context, *ListMyChannelsReq) (*ListMyChannelsResp, error)
	mustEmbedUnimplementedChannelServiceServer()
}

// UnimplementedChannelServiceServer must be embedded to have forward compatible implementations.
type UnimplementedChannelServiceServer struct {
}

func (UnimplementedChannelServiceServer) ChannelAfterKeepAlive(context.Context, *ChannelAfterKeepAliveReq) (*ChannelAfterKeepAliveResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelAfterKeepAlive not implemented")
}
func (UnimplementedChannelServiceServer) ChannelAfterOnline(context.Context, *ChannelAfterOnlineReq) (*ChannelAfterOnlineResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelAfterOnline not implemented")
}
func (UnimplementedChannelServiceServer) ChannelAfterOffline(context.Context, *ChannelAfterOfflineReq) (*ChannelAfterOfflineResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelAfterOffline not implemented")
}
func (UnimplementedChannelServiceServer) UpsertChannelMember(context.Context, *UpsertChannelMemberReq) (*UpsertChannelMemberResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpsertChannelMember not implemented")
}
func (UnimplementedChannelServiceServer) DeleteChannelMember(context.Context, *DeleteChannelMemberReq) (*DeleteChannelMemberResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteChannelMember not implemented")
}
func (UnimplementedChannelServiceServer) ListChannelSubscribers(context.Context, *ListChannelSubscribersReq) (*ListChannelSubscribersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListChannelSubscribers not implemented")
}
func (UnimplementedChannelServiceServer) ListMyChannels(context.Context, *ListMyChannelsReq) (*ListMyChannelsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMyChannels not implemented")
}
func (UnimplementedChannelServiceServer) mustEmbedUnimplementedChannelServiceServer() {}

// UnsafeChannelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChannelServiceServer will
// result in compilation errors.
type UnsafeChannelServiceServer interface {
	mustEmbedUnimplementedChannelServiceServer()
}

func RegisterChannelServiceServer(s grpc.ServiceRegistrar, srv ChannelServiceServer) {
	s.RegisterService(&ChannelService_ServiceDesc, srv)
}

func _ChannelService_ChannelAfterKeepAlive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelAfterKeepAliveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).ChannelAfterKeepAlive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.channelService/ChannelAfterKeepAlive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).ChannelAfterKeepAlive(ctx, req.(*ChannelAfterKeepAliveReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelService_ChannelAfterOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelAfterOnlineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).ChannelAfterOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.channelService/ChannelAfterOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).ChannelAfterOnline(ctx, req.(*ChannelAfterOnlineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelService_ChannelAfterOffline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelAfterOfflineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).ChannelAfterOffline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.channelService/ChannelAfterOffline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).ChannelAfterOffline(ctx, req.(*ChannelAfterOfflineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelService_UpsertChannelMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertChannelMemberReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).UpsertChannelMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.channelService/UpsertChannelMember",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).UpsertChannelMember(ctx, req.(*UpsertChannelMemberReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelService_DeleteChannelMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChannelMemberReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).DeleteChannelMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.channelService/DeleteChannelMember",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).DeleteChannelMember(ctx, req.(*DeleteChannelMemberReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelService_ListChannelSubscribers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChannelSubscribersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).ListChannelSubscribers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.channelService/ListChannelSubscribers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).ListChannelSubscribers(ctx, req.(*ListChannelSubscribersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChannelService_ListMyChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMyChannelsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChannelServiceServer).ListMyChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.channelService/ListMyChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChannelServiceServer).ListMyChannels(ctx, req.(*ListMyChannelsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ChannelService_ServiceDesc is the grpc.ServiceDesc for ChannelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChannelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.channelService",
	HandlerType: (*ChannelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ChannelAfterKeepAlive",
			Handler:    _ChannelService_ChannelAfterKeepAlive_Handler,
		},
		{
			MethodName: "ChannelAfterOnline",
			Handler:    _ChannelService_ChannelAfterOnline_Handler,
		},
		{
			MethodName: "ChannelAfterOffline",
			Handler:    _ChannelService_ChannelAfterOffline_Handler,
		},
		{
			MethodName: "UpsertChannelMember",
			Handler:    _ChannelService_UpsertChannelMember_Handler,
		},
		{
			MethodName: "DeleteChannelMember",
			Handler:    _ChannelService_DeleteChannelMember_Handler,
		},
		{
			MethodName: "ListChannelSubscribers",
			Handler:    _ChannelService_ListChannelSubscribers_Handler,
		},
		{
			MethodName: "ListMyChannels",
			Handler:    _ChannelService_ListMyChannels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "conversation.peer.proto",
}

// SessionServiceClient is the client API for SessionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionServiceClient interface {
	ListJoinedConversations(ctx context.Context, in *ListJoinedConversationsReq, opts ...grpc.CallOption) (*ListJoinedConversationsResp, error)
}

type sessionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionServiceClient(cc grpc.ClientConnInterface) SessionServiceClient {
	return &sessionServiceClient{cc}
}

func (c *sessionServiceClient) ListJoinedConversations(ctx context.Context, in *ListJoinedConversationsReq, opts ...grpc.CallOption) (*ListJoinedConversationsResp, error) {
	out := new(ListJoinedConversationsResp)
	err := c.cc.Invoke(ctx, "/pb.sessionService/ListJoinedConversations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionServiceServer is the server API for SessionService service.
// All implementations must embed UnimplementedSessionServiceServer
// for forward compatibility
type SessionServiceServer interface {
	ListJoinedConversations(context.Context, *ListJoinedConversationsReq) (*ListJoinedConversationsResp, error)
	mustEmbedUnimplementedSessionServiceServer()
}

// UnimplementedSessionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSessionServiceServer struct {
}

func (UnimplementedSessionServiceServer) ListJoinedConversations(context.Context, *ListJoinedConversationsReq) (*ListJoinedConversationsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListJoinedConversations not implemented")
}
func (UnimplementedSessionServiceServer) mustEmbedUnimplementedSessionServiceServer() {}

// UnsafeSessionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionServiceServer will
// result in compilation errors.
type UnsafeSessionServiceServer interface {
	mustEmbedUnimplementedSessionServiceServer()
}

func RegisterSessionServiceServer(s grpc.ServiceRegistrar, srv SessionServiceServer) {
	s.RegisterService(&SessionService_ServiceDesc, srv)
}

func _SessionService_ListJoinedConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJoinedConversationsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).ListJoinedConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.sessionService/ListJoinedConversations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).ListJoinedConversations(ctx, req.(*ListJoinedConversationsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionService_ServiceDesc is the grpc.ServiceDesc for SessionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.sessionService",
	HandlerType: (*SessionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListJoinedConversations",
			Handler:    _SessionService_ListJoinedConversations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "conversation.peer.proto",
}
